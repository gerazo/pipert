<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PipeRT: pipert::Scheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PipeRT
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A hybrid scheduling and dataflow framework for DSP applications</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classpipert_1_1Scheduler.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpipert_1_1Scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pipert::Scheduler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> is the main object of a pipeline that owns all <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects and is responsible for the scheduling of processing tasks.  
 <a href="classpipert_1_1Scheduler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Scheduler_8h_source.html">Scheduler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b0e69249794ff71b7fc96b416d292e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a2b0e69249794ff71b7fc96b416d292e0">Scheduler</a> (int workers=0, <a class="el" href="classpipert_1_1Profiler.html">Profiler</a> &amp;&amp;profiler=<a class="el" href="classpipert_1_1Profiler.html">Profiler</a>())</td></tr>
<tr class="memdesc:a2b0e69249794ff71b7fc96b416d292e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> object and the system enters preparation state.  <a href="classpipert_1_1Scheduler.html#a2b0e69249794ff71b7fc96b416d292e0">More...</a><br /></td></tr>
<tr class="separator:a2b0e69249794ff71b7fc96b416d292e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f0b0b817f6602a8aa2c715e8313ae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#aa9f0b0b817f6602a8aa2c715e8313ae5">~Scheduler</a> ()</td></tr>
<tr class="memdesc:aa9f0b0b817f6602a8aa2c715e8313ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object.  <a href="classpipert_1_1Scheduler.html#aa9f0b0b817f6602a8aa2c715e8313ae5">More...</a><br /></td></tr>
<tr class="separator:aa9f0b0b817f6602a8aa2c715e8313ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef858984c9bf1a55e7a7432f6439cc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#acef858984c9bf1a55e7a7432f6439cc9">Scheduler</a> (const <a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a> &amp;)=delete</td></tr>
<tr class="separator:acef858984c9bf1a55e7a7432f6439cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee884e25a69702493cbdbd158f6015d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a5ee884e25a69702493cbdbd158f6015d">operator=</a> (const <a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a> &amp;)=delete</td></tr>
<tr class="separator:a5ee884e25a69702493cbdbd158f6015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c082e4d372c712cf8740f411a05029"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af5c082e4d372c712cf8740f411a05029"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpipert_1_1PolledChannel.html">PolledChannel</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#af5c082e4d372c712cf8740f411a05029">CreatePolledChannel</a> (const char *name, int capacity)</td></tr>
<tr class="memdesc:af5c082e4d372c712cf8740f411a05029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classpipert_1_1PolledChannel.html" title="A Channel whose packets can be manually received for processing by the user&#39;s custom threads.">PolledChannel</a>.  <a href="classpipert_1_1Scheduler.html#af5c082e4d372c712cf8740f411a05029">More...</a><br /></td></tr>
<tr class="separator:af5c082e4d372c712cf8740f411a05029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7363bd83fcc4f747ce04f2e8e453e57"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac7363bd83fcc4f747ce04f2e8e453e57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpipert_1_1ScheduledChannel.html">ScheduledChannel</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#ac7363bd83fcc4f747ce04f2e8e453e57">CreateScheduledChannel</a> (const char *name, int capacity, void *single_thread_object, typename <a class="el" href="classpipert_1_1ScheduledChannel.html">ScheduledChannel</a>&lt; T &gt;::Callback callback)</td></tr>
<tr class="memdesc:ac7363bd83fcc4f747ce04f2e8e453e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classpipert_1_1ScheduledChannel.html" title="A Channel whose packets are automatically scheduled to be processed by a worker thread pool in a Sche...">ScheduledChannel</a>.  <a href="classpipert_1_1Scheduler.html#ac7363bd83fcc4f747ce04f2e8e453e57">More...</a><br /></td></tr>
<tr class="separator:ac7363bd83fcc4f747ce04f2e8e453e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925ad92fb3a9844be9ae8794d8ad7aed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a925ad92fb3a9844be9ae8794d8ad7aed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpipert_1_1SenderChannel.html">SenderChannel</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a925ad92fb3a9844be9ae8794d8ad7aed">CreateSenderChannel</a> (const char *name, int capacity, <a class="el" href="classpipert_1_1UDPConnection.html">UDPConnection</a> *connection)</td></tr>
<tr class="memdesc:a925ad92fb3a9844be9ae8794d8ad7aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classpipert_1_1SenderChannel.html" title="A Channel whose packets are automatically scheduled to be sent to the given remote computer.">SenderChannel</a>.  <a href="classpipert_1_1Scheduler.html#a925ad92fb3a9844be9ae8794d8ad7aed">More...</a><br /></td></tr>
<tr class="separator:a925ad92fb3a9844be9ae8794d8ad7aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04946ba198d580506d09f5202f87da24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a04946ba198d580506d09f5202f87da24">AddReceiver</a> (<a class="el" href="classpipert_1_1ReceiverBase.html">ReceiverBase</a> *receiver)</td></tr>
<tr class="memdesc:a04946ba198d580506d09f5202f87da24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new <a class="el" href="classpipert_1_1Receiver.html" title="Receiver side object of the pipeline over the network.">Receiver</a> object to the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>.  <a href="classpipert_1_1Scheduler.html#a04946ba198d580506d09f5202f87da24">More...</a><br /></td></tr>
<tr class="separator:a04946ba198d580506d09f5202f87da24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513c86b81c53fec57bf5383eb306e789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a513c86b81c53fec57bf5383eb306e789">Start</a> ()</td></tr>
<tr class="memdesc:a513c86b81c53fec57bf5383eb306e789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start all worker threads by entering <em>running state</em>.  <a href="classpipert_1_1Scheduler.html#a513c86b81c53fec57bf5383eb306e789">More...</a><br /></td></tr>
<tr class="separator:a513c86b81c53fec57bf5383eb306e789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01f1046f476cbe1aded81dc1d386c95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#ae01f1046f476cbe1aded81dc1d386c95">Stop</a> ()</td></tr>
<tr class="memdesc:ae01f1046f476cbe1aded81dc1d386c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a stop request to all worker threads and waits for them to shut down.  <a href="classpipert_1_1Scheduler.html#ae01f1046f476cbe1aded81dc1d386c95">More...</a><br /></td></tr>
<tr class="separator:ae01f1046f476cbe1aded81dc1d386c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fa414db7423bc6dde93b3199d93cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a56fa414db7423bc6dde93b3199d93cb9">SetStateInvalid</a> ()</td></tr>
<tr class="memdesc:a56fa414db7423bc6dde93b3199d93cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>'s state to invalid.  <a href="classpipert_1_1Scheduler.html#a56fa414db7423bc6dde93b3199d93cb9">More...</a><br /></td></tr>
<tr class="separator:a56fa414db7423bc6dde93b3199d93cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad700917bda40c6baedb4296f9f6578af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#ad700917bda40c6baedb4296f9f6578af">IsRunning</a> ()</td></tr>
<tr class="memdesc:ad700917bda40c6baedb4296f9f6578af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the current state of <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> (running or stopped/preparation).  <a href="classpipert_1_1Scheduler.html#ad700917bda40c6baedb4296f9f6578af">More...</a><br /></td></tr>
<tr class="separator:ad700917bda40c6baedb4296f9f6578af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5588baca5701b34f5f60b269010359"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#a5d5588baca5701b34f5f60b269010359">GetWorkerNumber</a> ()</td></tr>
<tr class="memdesc:a5d5588baca5701b34f5f60b269010359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the number of worker threads allocated to <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>.  <a href="classpipert_1_1Scheduler.html#a5d5588baca5701b34f5f60b269010359">More...</a><br /></td></tr>
<tr class="separator:a5d5588baca5701b34f5f60b269010359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa18bb2ea1c9d78037c3b64c419320d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpipert_1_1Profiler.html">Profiler</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpipert_1_1Scheduler.html#afa18bb2ea1c9d78037c3b64c419320d7">GetProfiler</a> ()</td></tr>
<tr class="memdesc:afa18bb2ea1c9d78037c3b64c419320d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classpipert_1_1Profiler.html" title="Controlling object of all profiling and monitoring functionality.">Profiler</a> of this <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>.  <a href="classpipert_1_1Scheduler.html#afa18bb2ea1c9d78037c3b64c419320d7">More...</a><br /></td></tr>
<tr class="separator:afa18bb2ea1c9d78037c3b64c419320d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> is the main object of a pipeline that owns all <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects and is responsible for the scheduling of processing tasks. </p>
<p>One <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> object governs a complete DSP pipeline, all its operations and the data structures that are connected to it. A <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> runs a real-time system when it is in its <em>running state</em>, so no memory allocations are done during the operation of the pipeline. This means that any configuration (including creating <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects) should be done before setting the pipeline into a the <em>running</em> state by using the <a class="el" href="classpipert_1_1Scheduler.html#a513c86b81c53fec57bf5383eb306e789" title="Start all worker threads by entering running state.">Start()</a> method.</p>
<p>A <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> keeps up a fixed number of <em>worker threads</em> that are used to execute processing functions of <em>nodes</em> connected to the receiver side of <a class="el" href="classpipert_1_1ScheduledChannel.html" title="A Channel whose packets are automatically scheduled to be processed by a worker thread pool in a Sche...">ScheduledChannel</a> objects. Scheduling is done by minimizing the delay between useful work units and also minimizing the amount of time a <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> spends in the pipeline.</p>
<p>During the operation of the pipeline, no memory is allocated. All <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects use a fixed, preconfigured size buffer where <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> objects stay in place. This way, buffers are not moved in memory and transforming operations push the data forward from one buffer to an other one residing in the next <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> in the pipeline.</p>
<p>There is an option to connect your own, custom threads to the pipeline by using a <a class="el" href="classpipert_1_1PolledChannel.html" title="A Channel whose packets can be manually received for processing by the user&#39;s custom threads.">PolledChannel</a>. A <a class="el" href="classpipert_1_1PolledChannel.html" title="A Channel whose packets can be manually received for processing by the user&#39;s custom threads.">PolledChannel</a> has all the buffering functionality but the <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> objects in its buffer are not subject to scheduling done by the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>. Instead, the user can poll the buffer from a custom thread. This can be used to implement <em>UI threads</em> or to create <em>exit points</em> from the pipeline transferring data to an other system.</p>
<p>A pipeline ran by a <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> is really flexible. You can have an arbitrary number of <em>entry and exit points</em> and also <em>feedback loops</em> in the chain. Until timestamps are correct, scheduling is done accordingly.</p>
<p>To ease creating and changing pipelines during development, the structure of a pipeline is not stored by the system. Instead, direct connections and references to <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects from user supplied <em>nodes</em> are governing the flow direction of data. Nevertheless, this data flow can be traced and measured nicely by the built-in monitoring system.</p>
<p>You can have multiple <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> objects running in parallel. This means you will run more, completely independent pipelines together. However, you should keep in mind that these will fight for the same CPU resources despite being isolated in memory. </p>

<p class="definition">Definition at line <a class="el" href="Scheduler_8h_source.html#l00063">63</a> of file <a class="el" href="Scheduler_8h_source.html">Scheduler.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2b0e69249794ff71b7fc96b416d292e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0e69249794ff71b7fc96b416d292e0">&#9670;&nbsp;</a></span>Scheduler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pipert::Scheduler::Scheduler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>workers</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpipert_1_1Profiler.html">Profiler</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>profiler</em> = <code><a class="el" href="classpipert_1_1Profiler.html">Profiler</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> object and the system enters preparation state. </p>
<p>The <em>preparation</em> or <em>set up</em> state is for creating <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects and any kind of configuration which involves memory allocations or is otherwise slow. You can create channels by calling <a class="el" href="classpipert_1_1Scheduler.html#ac7363bd83fcc4f747ce04f2e8e453e57" title="Create a ScheduledChannel.">CreateScheduledChannel()</a> or <a class="el" href="classpipert_1_1Scheduler.html#af5c082e4d372c712cf8740f411a05029" title="Create a PolledChannel.">CreatePolledChannel()</a>. You can enter <em>running state</em> by calling <a class="el" href="classpipert_1_1Scheduler.html#a513c86b81c53fec57bf5383eb306e789" title="Start all worker threads by entering running state.">Start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workers</td><td>Number of worker threads to be used for scheduling. By default or for non-positive numbers, it detects the number of CPUs in the system and starts that many threads. </td></tr>
    <tr><td class="paramname">profiler</td><td><a class="el" href="classpipert_1_1Profiler.html" title="Controlling object of all profiling and monitoring functionality.">Profiler</a> object created to send logs to destination. The default is a null object doing nothing. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00013">13</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="aa9f0b0b817f6602a8aa2c715e8313ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f0b0b817f6602a8aa2c715e8313ae5">&#9670;&nbsp;</a></span>~Scheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pipert::Scheduler::~Scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the object. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> should be in <em>preparation/stopped</em> state, or this needs to issue a complete stop of worker threads and wait for them to shut down. </dd>
<dd>
It is also a requirement that all <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects are destroyed by this point to have a clean shutdown. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00020">20</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="acef858984c9bf1a55e7a7432f6439cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef858984c9bf1a55e7a7432f6439cc9">&#9670;&nbsp;</a></span>Scheduler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pipert::Scheduler::Scheduler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a04946ba198d580506d09f5202f87da24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04946ba198d580506d09f5202f87da24">&#9670;&nbsp;</a></span>AddReceiver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pipert::Scheduler::AddReceiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpipert_1_1ReceiverBase.html">ReceiverBase</a> *&#160;</td>
          <td class="paramname"><em>receiver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new <a class="el" href="classpipert_1_1Receiver.html" title="Receiver side object of the pipeline over the network.">Receiver</a> object to the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td><a class="el" href="classpipert_1_1Receiver.html" title="Receiver side object of the pipeline over the network.">Receiver</a> object to be registered into the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00055">55</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="af5c082e4d372c712cf8740f411a05029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c082e4d372c712cf8740f411a05029">&#9670;&nbsp;</a></span>CreatePolledChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpipert_1_1PolledChannel.html">PolledChannel</a>&lt; T &gt; pipert::Scheduler::CreatePolledChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classpipert_1_1PolledChannel.html" title="A Channel whose packets can be manually received for processing by the user&#39;s custom threads.">PolledChannel</a>. </p>
<p>This is the function you should use to create a <a class="el" href="classpipert_1_1PolledChannel.html" title="A Channel whose packets can be manually received for processing by the user&#39;s custom threads.">PolledChannel</a>. See <a class="el" href="classpipert_1_1PolledChannel.html" title="A Channel whose packets can be manually received for processing by the user&#39;s custom threads.">PolledChannel</a> for details. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>See <code><a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a>&lt;T&gt;</code> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The preferably unique name of the to-be-created <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> which will be used for identification in logs, monitoring annd debugging. See <a class="el" href="classpipert_1_1ChannelBase.html#a3bff59307f7c4c0f56d873575a43b121" title="Get the name of this Channel.">ChannelBase::GetName()</a> for details. </td></tr>
    <tr><td class="paramname">capacity</td><td>The number of <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> objects that the to-be-created <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> can hold. See <a class="el" href="classpipert_1_1ChannelBase.html#a2f67cb774316448b5a1e112bb97ac0d3" title="Get the maximum amount of packets the buffer of this Channel can hold.">ChannelBase::GetCapacity()</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8h_source.html#l00224">224</a> of file <a class="el" href="Scheduler_8h_source.html">Scheduler.h</a>.</p>

</div>
</div>
<a id="ac7363bd83fcc4f747ce04f2e8e453e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7363bd83fcc4f747ce04f2e8e453e57">&#9670;&nbsp;</a></span>CreateScheduledChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpipert_1_1ScheduledChannel.html">ScheduledChannel</a>&lt; T &gt; pipert::Scheduler::CreateScheduledChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>single_thread_object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classpipert_1_1ScheduledChannel.html">ScheduledChannel</a>&lt; T &gt;::Callback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classpipert_1_1ScheduledChannel.html" title="A Channel whose packets are automatically scheduled to be processed by a worker thread pool in a Sche...">ScheduledChannel</a>. </p>
<p>This is the function you should use to create a <a class="el" href="classpipert_1_1ScheduledChannel.html" title="A Channel whose packets are automatically scheduled to be processed by a worker thread pool in a Sche...">ScheduledChannel</a>. See <a class="el" href="classpipert_1_1ScheduledChannel.html" title="A Channel whose packets are automatically scheduled to be processed by a worker thread pool in a Sche...">ScheduledChannel</a> for details. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>See <code><a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a>&lt;T&gt;</code> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The preferably unique name of the to-be-created <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> which will be used for identification in logs, monitoring and debugging. See <a class="el" href="classpipert_1_1ChannelBase.html#a3bff59307f7c4c0f56d873575a43b121" title="Get the name of this Channel.">ChannelBase::GetName()</a> for details. </td></tr>
    <tr><td class="paramname">capacity</td><td>The number of <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> objects that the to-be-created <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> can hold. See <a class="el" href="classpipert_1_1ChannelBase.html#a2f67cb774316448b5a1e112bb97ac0d3" title="Get the maximum amount of packets the buffer of this Channel can hold.">ChannelBase::GetCapacity()</a>. </td></tr>
    <tr><td class="paramname">single_thread_object</td><td>This parameter determines the mutual exclusion the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> will employ when calling the registered callback function. This depends on the <em>Node</em> which will be called. There are 3 typical scenarios:<ul>
<li>For <em>stateless</em> node objects, use <code>nullptr</code>, so all free threads can call the registered callback simultaneously. This will allow full parallelism processing multiple packets simultaneously. The drawback is that the called function (or Node object) should only use local or <code>thread_local</code> resources to avoid conflicting with itself.</li>
<li>For <em>stateful</em> nodes, give a unique pointer here, practically your Node object's <code>this</code> pointer. In this case, only one thread will enter your object code at any single time, so you can use object member data without any synchronization primitives.</li>
<li>For <em>stateful</em> nodes with multiple <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects, use the same pointer in all to-be-created channels connecting to the same object. (Practically the same this pointer.) This way, from all <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects connected to your Node, only one callback will be scheduled at the same time. This implements mutual exclusion between all connected channels. This also allows normal member data usage without parallel primitives in case of complex Nodes having multiple input channels. </li>
</ul>
</td></tr>
    <tr><td class="paramname">callback</td><td>A callback function to be registered in the new <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a>. This is the function a worker thread of the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> will call when a <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> in the <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> is scheduled for processing. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8h_source.html#l00232">232</a> of file <a class="el" href="Scheduler_8h_source.html">Scheduler.h</a>.</p>

</div>
</div>
<a id="a925ad92fb3a9844be9ae8794d8ad7aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925ad92fb3a9844be9ae8794d8ad7aed">&#9670;&nbsp;</a></span>CreateSenderChannel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpipert_1_1SenderChannel.html">SenderChannel</a>&lt; T &gt; pipert::Scheduler::CreateSenderChannel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpipert_1_1UDPConnection.html">UDPConnection</a> *&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classpipert_1_1SenderChannel.html" title="A Channel whose packets are automatically scheduled to be sent to the given remote computer.">SenderChannel</a>. </p>
<p>This is the function you should use to create a <a class="el" href="classpipert_1_1SenderChannel.html" title="A Channel whose packets are automatically scheduled to be sent to the given remote computer.">SenderChannel</a>. See <a class="el" href="classpipert_1_1SenderChannel.html" title="A Channel whose packets are automatically scheduled to be sent to the given remote computer.">SenderChannel</a> for details. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>See <code><a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a>&lt;T&gt;</code> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The preferably unique name of the to-be-created <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> which will be used for identification in logs, monitoring and debugging. See <a class="el" href="classpipert_1_1ChannelBase.html#a3bff59307f7c4c0f56d873575a43b121" title="Get the name of this Channel.">ChannelBase::GetName()</a> for details. </td></tr>
    <tr><td class="paramname">capacity</td><td>The number of <a class="el" href="classpipert_1_1Packet.html" title="Represents data which is transmitted between nodes for processing.">Packet</a> objects that the to-be-created <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> can hold. See <a class="el" href="classpipert_1_1ChannelBase.html#a2f67cb774316448b5a1e112bb97ac0d3" title="Get the maximum amount of packets the buffer of this Channel can hold.">ChannelBase::GetCapacity()</a>. </td></tr>
    <tr><td class="paramname">connection</td><td>Network properties of the receiver side computer. See <a class="el" href="classpipert_1_1UDPConnection.html" title="This class is responsible for UDP communication.">UDPConnection</a> for details. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8h_source.html#l00242">242</a> of file <a class="el" href="Scheduler_8h_source.html">Scheduler.h</a>.</p>

</div>
</div>
<a id="afa18bb2ea1c9d78037c3b64c419320d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa18bb2ea1c9d78037c3b64c419320d7">&#9670;&nbsp;</a></span>GetProfiler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpipert_1_1Profiler.html">Profiler</a> &amp; pipert::Scheduler::GetProfiler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classpipert_1_1Profiler.html" title="Controlling object of all profiling and monitoring functionality.">Profiler</a> of this <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>. </p>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00051">51</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="a5d5588baca5701b34f5f60b269010359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5588baca5701b34f5f60b269010359">&#9670;&nbsp;</a></span>GetWorkerNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pipert::Scheduler::GetWorkerNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the number of worker threads allocated to <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>. </p>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00046">46</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="ad700917bda40c6baedb4296f9f6578af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad700917bda40c6baedb4296f9f6578af">&#9670;&nbsp;</a></span>IsRunning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pipert::Scheduler::IsRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the current state of <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> (running or stopped/preparation). </p>
<dl class="section return"><dt>Returns</dt><dd>True if <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> is running. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00041">41</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="a5ee884e25a69702493cbdbd158f6015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee884e25a69702493cbdbd158f6015d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a>&amp; pipert::Scheduler::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56fa414db7423bc6dde93b3199d93cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fa414db7423bc6dde93b3199d93cb9">&#9670;&nbsp;</a></span>SetStateInvalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pipert::Scheduler::SetStateInvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>'s state to invalid. </p>
<p>If a <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> is in invalid state it cannot be started. </p>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00036">36</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="a513c86b81c53fec57bf5383eb306e789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513c86b81c53fec57bf5383eb306e789">&#9670;&nbsp;</a></span>Start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pipert::Scheduler::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start all worker threads by entering <em>running state</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>We should be in <em>preparation/stopped</em> state. It is not possible to restart a <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>, but it is possible to Stop and Start it again. </dd>
<dd>
All <a class="el" href="classpipert_1_1Channel.html" title="A Channel represents storage for a single stage in the data processing chain, and receives data of ty...">Channel</a> objects were created, capacities are allocated and all references are in place to enter running state, so no configuration has to be done while running the <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00026">26</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<a id="ae01f1046f476cbe1aded81dc1d386c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01f1046f476cbe1aded81dc1d386c95">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pipert::Scheduler::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a stop request to all worker threads and waits for them to shut down. </p>
<dl class="section pre"><dt>Precondition</dt><dd>We should be in <em>running state</em>. It is not possible to Stop a stopped <a class="el" href="classpipert_1_1Scheduler.html" title="A Scheduler is the main object of a pipeline that owns all Channel objects and is responsible for the...">Scheduler</a> but it is possible Start it and Stop it as many times as you want. The corresponding thread pool is always rebuilt from scratch after a clean shutdown. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Scheduler_8cpp_source.html#l00031">31</a> of file <a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/pipert/pipert/include/pipert/<a class="el" href="Scheduler_8h_source.html">Scheduler.h</a></li>
<li>/home/runner/work/pipert/pipert/src/<a class="el" href="Scheduler_8cpp_source.html">Scheduler.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepipert.html">pipert</a></li><li class="navelem"><a class="el" href="classpipert_1_1Scheduler.html">Scheduler</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
